---
layout: post
title:  "Day9 探路引用类型 "
date:   2017-06-08
categories: 《JavaScript高级程序设计》笔记
spend: 5h
excerpt: ""
---
#### 一、数组
##### 1、位置方法
indexOf和lastIndexOf是通过全等于(`===`)来查找匹配的
{% highlight javascript %}  
    var person = { name: 'Tom' };
    var people = [{ name: 'Tom' }];
    
    var morePeople = [person];
    alert(people.indexOf(person));  //-1
    alert(morePeople.indexOf(person));  //0    
{% endhighlight %} 
且lastIndexOf是从末尾开始。
##### 2.迭代方法
* every():对数组中的每一项运行给定函数，如果该函数每一项都返回true，那就返回true
* some():对数组中的每一项运行给定函数，如果该函数至少有一项返回true，那就返回true
* filter():对数组中的每一项运行给定函数，返回该函数会返回true的项组成数组  

用来用去都是map和forEach，还有这几个好用的方法，留意下。
#### 二、有趣的Date对象
提到`Date`对象就是一大堆的方法，前端和它常打交道的场景通常是做日期范围查询传递数据给后端。恰好刚才发现了一个有趣的地方。

使用`Date.parse()`方法可以把一个表示日期的字符串转换为相应的毫秒数，如:
{% highlight javascript %}  
    Date.parse('2017-06-8');     //1496851200000 
    Date.parse('2017-6-08');     //1496851200000 
    Date.parse('2017-6-8');      //1496851200000
    Date.parse('2017-06-08');    //1496880000000
    (1496880000000 - 1496851200000)/(1000 * 3600);  //8
{% endhighlight %} 
可以看到，前三种使用非`yyyy-mm-dd`格式的字符串，得到的返回值比使用`yyyy-mm-dd`格式得到的时间值少了8小时，格林威治作为世界时间，比中国的本地时间慢了8小时，因此我推测`yyyy-mm-dd`格式的字符串通过`Date.parse()`得到的是中国时间，否则就是世界时间。在真实的使用场景中，只要保证两端取同一个时区的时间来计算，也就不会出现误差了。
#### 三、正则表达式-IE9以下的问题
使用字面量`/example/g`定义的正则表达式始终会共享一个实例，循环使用时可能会与预期出现误差，需注意。
#### 四、arguments的属性-callee
`callee`是对象`arguments`对象的一个属性，保存了拥有这个`arguments`的函数。

`callee`有一个属性`callee.caller`，保存着调用当前函数的函数引用，如果实在全局作用域中调用该函数，该值为`null`。

这两点在给函数名解耦时(递归)很有用。

#### 五、函数的属性和方法
##### 1.属性
* length:表示函数希望接收的参数个数
* prototype:保存所有的实例方法

##### 2.方法
apply()和call()，它们都是都是用来改变函数体内的`this`值，区别在于所接收的参数不同，它们第一个参数都接收要运行的作用域，不同的是call()`传递的第二个参数必须逐个列出来，而`apply()`的第二个参数可以是数组Array的实例。  
通过`apply()`方法可以解析Array实例的特性，有了以下的两个黑科技:
* Math.max.apply(null， `array`)  //得出数组`array`的最大值
* Array.prototype.push.apply(`arr1`， `arr2`);  //合并`arr1、arr2`数组