---
layout: post
title:  "Day5 参数传递是引用传递?不存在的 "
date:   2017-06-04
categories: 我可能不会JavaScript
excerpt: ""
---
照例先看个问题:  
{% highlight javascript %}
function setName(obj){
    obj.name = "bulger";
    obj = new Object();
    obj.name = "admin";
}
var person = new Object();
setName(person);
alert(person.name);     //? bulger
{% endhighlight %} 
好尴尬,又猜错了,这是为什么呢?我们慢慢来分析。  

js的变量包含两种数据类型:基本数据类型和引用数据类型。我们分别来看用这两种数据类型作为参数传递时的情况。  

①基本数据类型:
{% highlight javascript %}
function add(num){
   num+=10;
   return num;
}
num=10;
alert(add(num));    //20
aelrt(num);         //10
{% endhighlight %} 
对于这个结果是不是也挺吃惊的。原来,在进行基本类型参数传递的时候,做了一个复制栈帧的拷贝动作,这样使得外部变量`num`和函数参数`num`具有了相同的值,但是它们参数地址完全不同,在函数调用结束后回收该栈帧,这种机制一定程度上避免了内存泄漏。所以改变了函数参数`num`,并不会对外部的变量`num`有影响。  

②引用数据类型:
{% highlight javascript %}
function setName(obj){
    obj.name="bulger";
}
var obj=new Object();
setName(obj);
alert(obj.name);
//bulger
{% endhighlight %} 
以上代码运行时,首先把新创建的Object对象的引用赋值给了obj,在进行参数传递时,同上一个方法一样,复制出一个栈帧给参数obj,使得两者拥有相同的值(`Object对象的引用地址`),然后在setName做改变的时候,实际上改变了Object对象的值,改变完成后弹出该栈帧。那这样是否就可以得出js里的函数参数传递机制有`值传递`和`引用传递`两种方式了呢?

不一定。先来看看函数参数传递机制的两种定义。
> 函数参数传递机制问题在本质上是调用函数（过程）和被调用函数（过程）在调用发生时进行通信的方法问题。基本的参数传递机制有两种：值传递和引用传递。以下讨论称调用其他函数的函数为主调函数，被调用的函数为被调函数。   
    　　值传递（passl-by-value）过程中，被调函数的形式参数作为被调函数的局部变量处理，即在堆栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。   
    　　引用传递(pass-by-reference)过程中，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

从①例子里可见,基本数据类型的参数传递是属于值传递的。我们回到一开始的那个问题里:在没有重新定义obj之前,变量person和函数参数obj的值相等,都是对同一个对象的引用地址,执行第一个`obj.name = bulger`时,也会改变原对象的值,但在重新定义obj后,其引用的对象已经和person不同,所以后面设置的name属性,不会再对原对象有影响。即不满足函数参数引用传递机制的定义:`被调函数对形参做的任何操作都影响了主调函数中的实参变量`,因此得出结论:`js里的函数参数传递不存在引用传递,只有值传递`。