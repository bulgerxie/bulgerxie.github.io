---
layout: post
title:  "Day3 从闭包来看作用域 "
date:   2017-06-02
categories: 我可能不会JavaScript
excerpt: ""
---

js里的闭包,简单来说就是`在函数内部定义一个函数`
{% highlight javascript %}  
    function say1() {
        var test = 'hello';
        var say2 = function(){
            alert(test);
        }
        return say2;
    }
    var said = say1();
    said();
{% endhighlight %}  
像这样,我们通过返回的`say2`方法在外部获取到函数内部的`test`变量。这是闭包的第一个用途,`在函数外部读取函数内部的变量`。
今天主要是记录另一个用途,`让变量始终保存在内存中`。先看例子:
{% highlight javascript %}  
    function say1(){
        var n = 333;
        nAdd = function() {
            n += 1;
        }
        function say2() {
            alert(n);
        }
        return say2;
    }
    var said = say1();
    said();     //333
    nAdd();
    said();     //334
{% endhighlight %} 
从结果里我们看到,执行了两次闭包函数`say2`,第一次结果为`333`,第二次为`334`,`n`作为`say1`的局部变量,并没有在函数调用完后被清除掉。原因在于`say1`是`say2`的父函数,但`say2`被赋给了全局变量`said`,这导致`say2`会始终在内存中,而`say2`依赖于`say1`,因此`say1`也会在内存中,不会被GC(垃圾回收机制)回收。  

查了一下资料,大概了解了一下GC,得出如下总结:   

   `为了避免内存泄漏,语言引擎会释放内存中不再引用的资源,通常是用一张"引用表"来记录内存中所有资源的引用情况.如果一个值引用数为"0",那么这块内存就会被释放.引用类型是在没有引用之后,会被GC自动回收,如果是处于闭包中值类型,则要等闭包没有引用时才会被回收.`
   
这样也就可以从根本上来解释变量`n`依然保存在内存中的原因了。

